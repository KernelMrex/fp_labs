# Задание

Изучаем функции стандартных модулей. (Командная работа).

Для изучения предлагаются функции стандартных модулей. В каждой команде распределяются функции между участниками - по согласованию с командой каждый участник набирает свой набор функций из разных модулей.

Каждый участник минигруппы, используя материал Функции стандартных модулей готовит описание 5 функций по указанным модулям.

1 балл за каждую функцию

Описание функции включает:
- Название, тип, что делает.
- примеры использования функции (не менее 3 примеров).
- Собственная реализация описываемой функции.

4 балла (по 2 балла за каждый вопрос) - оценивает преподаватель

От участника - 2 вопроса для тестирования по предлагаемым функциям. (Примеры тестовых вопросов можно посмотреть в тестах по пройденным темам)

до 3 баллов

Доп. задание - примеры реализации описываемых функции альтернативными способами. (Дополнительный балл дается за реализацию другим способом описываемой участником функции)

# Ответ
## Data.List find
### Название, тип, что делает.
**Название**: find

**Тип**: `find :: (a -> Bool) -> [a] -> Maybe a`

**Описание**: Функция find принимает предикат (функцию, возвращающую булево значение) и список. Она возвращает первый элемент списка, который удовлетворяет предикату, обернутый в Just, если такой элемент найден, или Nothing, если такой элемент не существует.

### Примеры использования:

```
-- Пример 1: Поиск элемента, удовлетворяющего предикату
find (> 5) [1, 3, 7, 9, 2, 4]  
-- Результат: Just 7

-- Пример 2: Поиск строки в списке строк
find (\x -> length x > 3) ["apple", "banana", "pear", "kiwi"]
-- Результат: Just "apple"

-- Пример 3: Поиск элемента, не удовлетворяющего предикату
find even [1, 3, 5, 7]
-- Результат: Nothing
```

### Собственная реализация
```
myFind :: (a -> Bool) -> [a] -> Maybe a
myFind _ [] = Nothing
myFind p (x:xs)
  | p x       = Just x
  | otherwise = myFind p xs
```

Эта реализация `myFind` работает следующим образом:

Если список пуст, возвращается Nothing, так как в пустом списке нет элементов.
Если текущий элемент удовлетворяет предикату p, возвращается Just x.
В противном случае, вызывается рекурсивно myFind для хвоста списка xs.


## Data.List find
### Название, тип, что делает:
**Название**: `isLower`
**Тип**: `isLower :: Char -> Bool`
**Описание**: Функция `isLower` принимает символ и возвращает булево значение, указывающее, является ли этот символ строчной буквой в алфавите ASCII.

### Примеры использования:
```
-- Пример 1: Проверка символа на строчную букву
isLower 'a'
-- Результат: True

-- Пример 2: Проверка символа на строчную букву (в верхнем регистре)
isLower 'A'
-- Результат: False

-- Пример 3: Проверка символа на строчную букву (цифра)
isLower '3'
-- Результат: False
```

### Собственная реализация:
```
myIsLower :: Char -> Bool
myIsLower c = c >= 'a' && c <= 'z'
```

Эта реализация myIsLower проверяет, находится ли символ c в диапазоне от 'a' до 'z' в алфавите ASCII, что определяет, является ли символ строчной буквой.


## Data.Map lookup
### Название, тип, что делает:
**Название**: `lookup`
**Тип**: `lookup :: Ord k => k -> Map k a -> Maybe a`
Описание: Функция `lookup` принимает ключ и отображение (map) и возвращает `Just` с соответствующим значением, если ключ присутствует в отображении, и `Nothing` в противном случае.

### Примеры использования:
```
import qualified Data.Map as Map

-- Пример 1: Поиск значения по ключу в отображении
let myMap = Map.fromList [("key1", 10), ("key2", 20), ("key3", 30)]
Map.lookup "key2" myMap
-- Результат: Just 20

-- Пример 2: Поиск значения по ключу, которого нет в отображении
Map.lookup "key4" myMap
-- Результат: Nothing

-- Пример 3: Поиск значения по ключу в пустом отображении
Map.lookup "key1" Map.empty
-- Результат: Nothing
```

### Собственная реализация:
```
data Map k a = EmptyMap | Node k a (Map k a) (Map k a)

lookup :: Ord k => k -> Map k a -> Maybe a
lookup _ EmptyMap = Nothing
lookup key (Node k val left right)
  | key == k  = Just val
  | key < k   = lookup key left
  | otherwise = lookup key right
```

Этот код определяет тип данных Map и функцию lookup, которая рекурсивно проверяет каждый узел в отображении. Если ключ совпадает с ключом текущего узла, возвращается значение этого узла. Если ключ меньше текущего ключа, функция рекурсивно вызывается для левого поддерева, иначе для правого поддерева. Если достигнут конец отображения (EmptyMap), возвращается Nothing.

## Data.Set insert
### Название, тип, что делает:
**Название**: `insert`
**Тип**: `insert :: Ord a => a -> Set a -> Set a`
**Описание**: Функция `insert` принимает элемент и множество (set) и возвращает новое множество, содержащее все элементы исходного множества, а также новый элемент.

### Примеры использования:
```
import qualified Data.Set as Set

-- Пример 1: Вставка элемента в множество
let mySet = Set.fromList [1, 2, 3]
Set.insert 4 mySet
-- Результат: fromList [1,2,3,4]

-- Пример 2: Вставка уже существующего элемента
Set.insert 3 mySet
-- Результат: fromList [1,2,3]

-- Пример 3: Вставка элемента в пустое множество
Set.insert 5 Set.empty
-- Результат: fromList [5]
```

### Собственная реализация:
```
data Set a = EmptySet | Node a (Set a) (Set a)

insert :: Ord a => a -> Set a -> Set a
insert x EmptySet = Node x EmptySet EmptySet
insert x (Node y left right)
  | x == y    = Node y left right
  | x < y     = Node y (insert x left) right
  | otherwise = Node y left (insert x right)
```

Этот код определяет тип данных `Set` и функцию `insert`, которая рекурсивно проходит по множеству и вставляет новый элемент `x` в нужное место. Если элемент уже присутствует в множестве, то он не вставляется снова.

## Data.Char isUpper
### Название, тип, что делает:
**Название**: `isUpper`
**Тип**: `isUpper :: Char -> Bool`
**Описание**: Функция `isUpper` принимает символ и возвращает булево значение, указывающее, является ли этот символ заглавной буквой в алфавите ASCII.

### Примеры использования:
```
-- Пример 1: Проверка символа на заглавную букву
isUpper 'A'
-- Результат: True

-- Пример 2: Проверка символа на заглавную букву (в нижнем регистре)
isUpper 'b'
-- Результат: False

-- Пример 3: Проверка символа на заглавную букву (символ пунктуации)
isUpper '.'
-- Результат: False
```

### Собственная реализация:
```
myIsUpper :: Char -> Bool
myIsUpper c = c >= 'A' && c <= 'Z'
```

Эта реализация `myIsUpper` проверяет, находится ли символ c в диапазоне от 'A' до 'Z' в алфавите ASCII, что определяет, является ли символ заглавной буквой.
